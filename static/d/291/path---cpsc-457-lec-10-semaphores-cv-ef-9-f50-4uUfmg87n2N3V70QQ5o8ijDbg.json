{"data":{"markdownRemark":{"html":"<h2>Condition Variables</h2>\n<p>Condition variables are another type of synchronization primitives. They're used together with mutexes. CVs are perfect for implementing critical sections containing loops waiting for some condition.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">mutex <span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Critical section is protected with mutex `m`</span>\n<span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>condition<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The condition can only become true, if <strong>another thread runs it's critical section</strong>. A common pattern of using CVs:</p>\n<ul>\n<li>a thread enters it's critical section (locks a mutex)</li>\n<li>inside critical sections, thread needs to wait for some condition to become true</li>\n<li>but the condition can only become true by allowing some other thread to lock the mutex</li>\n<li>the thread has to wait and release the mutex</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">mutex <span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>condition<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>cv<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n<span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Now, some other thread can lock the mutex and execute code that will satisfy the condition. Eventually, the other thread:</p>\n<ul>\n<li>locks the mutex (optional)</li>\n<li>changes some state that will satisfy the condition</li>\n<li>notifies the waiting thread via condition variable</li>\n<li>releases the mutex (optional)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">mutex <span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  condition <span class=\"token operator\">=</span> TRUE<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span>cv<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>POSIX provides with <code class=\"language-text\">pthread_cond_t</code> condition variable with following functions:</p>\n<ul>\n<li><code class=\"language-text\">pthread_cond_wait(&amp;cond, &amp;mutex);</code>. Atomically releases mutex and causes the calling thread to block, until some other thread calls <code class=\"language-text\">pthread_cond_signal(&amp;cond)</code>. After returning, the mutex is automatically re-acquired, the condition is also must be checked due to <em>spurious wakeups</em>.</li>\n<li><code class=\"language-text\">pthread_cond_signal(&amp;cond);</code>. Wakes (signals) up thread waiting on <code class=\"language-text\">cond</code>. If no threads waiting on condition, the signal is lost. Must be followed by <code class=\"language-text\">pthread_mutex_unlock()</code> <strong>if the blocked thread uses the same mutex</strong>.</li>\n</ul>\n<p><strong>Example</strong>:</p>\n<p>Thread 1 decrementing counter, but never below 0, thread 2 incrementing counter. This doesn't have deadlocks and no busy waiting.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// Thread 1</span>\n\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">pthread_mutex_lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">pthread_cond_wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>cond<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  count<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">pthread_mutex_unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Thread 2</span>\n\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">pthread_mutex_lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  counter<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token function\">pthread_cond_signal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>cond<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">pthread_mutex_unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Semaphore</h2>\n<p>Semaphore is another synchronization primitive. A special integer variable used for signalling. The value could indicate number of available units of some resource. Semaphore supports three operations:</p>\n<ul>\n<li><strong>Initialization</strong>: can be initialized with any value 0 ... <code class=\"language-text\">INT_MAX</code></li>\n<li><strong>Decrement</strong>: reduces semaphore value by 1, blocks the calling process if &#x3C; 0; <code class=\"language-text\">down(s)</code> or <code class=\"language-text\">wait(s)</code>.</li>\n<li><strong>Increment</strong>: increases value by 1 and possibly unblocks another blocked prosess; <code class=\"language-text\">up(s)</code> or <code class=\"language-text\">signal(s)</code>.</li>\n</ul>\n<p>Semaphore can be used to protect critical sections, similar to a mutex:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">semaphore s<span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Critical section ...</span>\n<span class=\"token function\">signal</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Each semaphore maintains a queue of processes blocked on the semaphore. When a semaphore is locked by a thread, it can be unlocked by <strong>any thread</strong>, as opposed to a mutex, where locking/unlocking must be done by the same thread. That makes semaphores more suitable for producer-consumer problems.</p>\n<h3>Binary semaphore</h3>\n<p>It is a special type of semaphore, with value <code class=\"language-text\">[0, 1]</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  s <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  s <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Where the bodies are executed <strong>atomically</strong>. An <strong>atomic operation</strong> is an operation that <em>appears to execute instanteneously</em>, with respect to the rest of the system, e.g. it cannot be interrupted by signals, threads, interrupts.</p>\n<h3>Counting semaphore</h3>\n<p>A <strong>general semaphore</strong>, represents an integer value <code class=\"language-text\">S</code>, where:</p>\n<ul>\n<li><code class=\"language-s \"> 0</code>: value of <code class=\"language-text\">S</code> is the number of processes/threads that can issue a wait and immediately continue to execute.</li>\n<li><code class=\"language-text\">S = 0</code>: all resources are busy, the calling thread/process must wait</li>\n<li><code class=\"language-text\">S &lt; 0</code>: (not all implementations do this), <code class=\"language-text\">abs(S)</code> represents the number of processes/threads that are waiting to be unblocked.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  s<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  s<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Where the functions are executed <strong>atomically</strong>.</p>\n<h2>Semaphores vs. Condition Variables</h2>\n<ul>\n<li>\n<p><code class=\"language-text\">signal()</code> compared to <code class=\"language-text\">cv_signal()</code>:</p>\n<ul>\n<li><code class=\"language-text\">cv_signal()</code> is lost, if no thread is waiting.</li>\n<li><code class=\"language-text\">signal()</code> increments the semaphore always, and possibly wakes up a thread.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">wait()</code> compared to <code class=\"language-text\">cv_wait</code>:</p>\n<ul>\n<li><code class=\"language-text\">cv_wait()</code> does not check the condition, always blocks.</li>\n<li><code class=\"language-text\">wait()</code> checks the value of the semaphore and may or may no block.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Possible errors</strong></p>\n<p>You need to be careful with order in which <code class=\"language-text\">signal</code> and <code class=\"language-text\">wait</code> are called.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">/*\n * The following will violate mutual exclusivity\n */</span>\n<span class=\"token function\">signal</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Critical section ...</span>\n<span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/*\n * This will lead to deadlock\n */</span>\n<span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Critical section ...</span>\n<span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"date":"February 14, 2019","title":"More Synchronization Mechanisms","tags":["cpsc457"]}}},"pageContext":{"prev":{"fields":{"slug":"/cpsc457/lec9-mutexes-locks-dining-philosophers"},"frontmatter":{"published":true,"tags":["cpsc457","multithreading","concurrency"]}},"slug":"/cpsc457/lec10-semaphores-cv","next":{"fields":{"slug":"/cpsc457/lec11-more-synchronization"},"frontmatter":{"published":true,"tags":["cpsc457"]}},"category":"cpsc457"}}