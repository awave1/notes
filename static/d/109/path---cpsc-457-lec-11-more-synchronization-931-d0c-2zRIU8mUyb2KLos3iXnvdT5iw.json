{"data":{"markdownRemark":{"html":"<h2>Monitors</h2>\n<p>A <strong>monitor</strong> is a high level construct compared to mutexes and semaphores. A monitor is a <strong>programming language construct</strong> that controls access to shared data. Synchronization code automatically added by a compiler, then enforced at runtime. e.g. in Java, implemented using <code class=\"language-text\">synchronized() {...}</code>.</p>\n<p>A monitor is a module that encapsulates:</p>\n<ul>\n<li>Shared data structure</li>\n<li>Methods that operate on these shared data structures</li>\n<li>Synchronization is done between concurrent method invocations</li>\n</ul>\n<p>Data in monitors can only be accessed via the published methods. A properly implemented monitor is virtually impossible to use in a wrong way.</p>\n<p>Another way to look at a monitor is:</p>\n<ul>\n<li>a thread safe class/object</li>\n<li>automatic mutual exclusion on every method (via built-in mutex)</li>\n<li>can include condition variables for signalling conditions</li>\n</ul>\n<!-- todo: finish -->\n<h2>Spinlocks</h2>\n<p>Spinlock is another synchronization mechanism. It's lightweight alternative to mutex. Implemented using busy waiting loops. Usually implemented in assembly, using <strong>atomic operations</strong>. It's very efficient if you know that wait time will be very short, because no re-scheduling required (only makes sense on multicore CPUs).</p>\n<blockquote>\n<p>Atomic operation - an operation that appears to execute instantaneously with respect to the rest of the system, i.e. it cannot be <em>interrupted</em> by anything else</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">spinlock s<span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">spin_lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/* short critical section */</span>\n<span class=\"token function\">spin_unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>Other synchronization mechanisms</h2>\n<p><strong>Event flags</strong></p>\n<p>A memory word with N bits. Different events may be associated with different bits in a flag. Available operations:</p>\n<ul>\n<li>Set flag</li>\n<li>Clear flag</li>\n<li>Wait for 1 flag</li>\n<li>Wait for any flag</li>\n<li>Wait for all flags</li>\n</ul>\n<p><strong>Message passing</strong></p>\n<p>Processes send each other <strong>messages</strong>. Messages can contain arbitrary data, delivered messages can be up in <strong>mailboxes</strong>. Processes can check contents of mailboxes, take messages out, or wait for messages. Common implementation is MPI (message passing interface). It's very popular in HPC (high performance computers).</p>\n<p>Processes send each other <strong>messages</strong>. Messages can contain arbitrary data. Delivered messages can be queues up in <strong>mailboxes</strong>. Process can check contents of mailboxes, take messages out, or wait for messages. Common implementation is MPI (Message passing interface).</p>\n<h2>Priority inversion</h2>\n<!-- TODO: Finish all before synch hardware -->\n<h2>Synchronization hardware</h2>\n<p>Race conditions are prevented by ensuring that critical sections are protected by locks:</p>\n<ul>\n<li>A process must acquire a lock before entering a CS</li>\n<li>A process releases the lock when it exits the CS</li>\n</ul>\n<p>Many modern systems provide special hardware instructions that implement useful atomic operations.</p>\n<h3>Compare-and-swap (CAS)</h3>\n<p>Atomic operation used for synchronization. It's supported by most CPUs, e.g. <code class=\"language-text\">cmpxchg</code> on Intel. General algorithm for compare and swap:</p>\n<ul>\n<li>Compare contents of memory to <code class=\"language-text\">val1</code></li>\n<li>If they are the same, change the memory to <code class=\"language-text\">val2</code></li>\n<li>Return the old contents of memory</li>\n</ul>\n<p>Operation must be atomic.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> cas <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>mem<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> val1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> val2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> old <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>mem<span class=\"token punctuation\">;</span>     <span class=\"token comment\">//</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>old <span class=\"token operator\">==</span> val1<span class=\"token punctuation\">)</span>    <span class=\"token comment\">// Must be atomic! Can't implement it in c</span>\n    <span class=\"token operator\">*</span>mem <span class=\"token operator\">=</span> val2<span class=\"token punctuation\">;</span>      <span class=\"token comment\">//</span>\n  <span class=\"token keyword\">return</span> old<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Usage:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> p <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token function\">cas</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* wait loop */</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// Critical section</span>\n  p <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// Non-critical section</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Compare-and-swap in GCC 4.4+</strong></p>\n<p><code class=\"language-text\">gcc</code> provides a number of atomic operations, including CAS:</p>\n<ul>\n<li>\n<p><code class=\"language-text\">type __sync_val_compare_and_swap(type *ptr, type oldval, type newval)</code></p>\n<ul>\n<li>atomic compare and swap</li>\n<li>if the current value of <code class=\"language-text\">*ptr</code> is <code class=\"language-text\">oldval</code>, then write <code class=\"language-text\">newval</code> into <code class=\"language-text\">*ptr</code></li>\n<li>returns the original value of <code class=\"language-text\">*ptr</code></li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">bool __sync_bool_compare_and_swap(type *ptr, type oldval, type newval)</code></p>\n<ul>\n<li>same as above, but return <code class=\"language-text\">true</code> if <code class=\"language-text\">newval</code> was written</li>\n</ul>\n</li>\n</ul>\n<p><strong>Spinlock using compare-and-swap</strong>:</p>\n<!-- TODO: Finish -->\n<h3>Test-and-set</h3>\n<p>A specialized version of compare-and-swap. Old hardware had test-and-set, newer hardware uses more generalized compare-and-swap. General algorithm:</p>\n<ul>\n<li>remember contents of memory</li>\n<li>set memory to true</li>\n<li>return the old contents of memory</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">tas</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>mem<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> old <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>mem<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//</span>\n  <span class=\"token operator\">*</span>mem <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// atomic!</span>\n  <span class=\"token keyword\">return</span> old<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Usage:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> p <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">tas</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// critical section</span>\n  p <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// non-critical section</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Swap</h3>\n<p>Another atomic operation that can be used for synchronization. General algorithm:</p>\n<ul>\n<li>atomically swap contents of two memory location</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> tmr <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>a<span class=\"token punctuation\">;</span> <span class=\"token comment\">//</span>\n  <span class=\"token operator\">*</span>a <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>b<span class=\"token punctuation\">;</span>      <span class=\"token comment\">// atomic!</span>\n  <span class=\"token operator\">*</span>b <span class=\"token operator\">=</span> tmr<span class=\"token punctuation\">;</span>     <span class=\"token comment\">//</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Usage:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> lock <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> key <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>lock<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// critical section</span>\n  lock <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// non-critical section</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<hr>\n<h3>Bounded waiting with synchronization hardware</h3>\n<p>When used correctly, the atomic operations, such as compare-and-swap, test-and-set, swap can be used to achieve mutual exclusion, progress and speed. But they are too low level to achieve bounded waiting, especially for more than 2 processes. Bounded waiting can be 'added', e.g. via two shared variables:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// a CS lock</span>\n<span class=\"token keyword\">int</span> lock<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// which processes want to enter CS</span>\n<span class=\"token keyword\">int</span> waiting<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// TODO</span></code></pre></div>\n<hr>\n<p>Synchronization hardware can be used to implement mutual exclusion, progress, speed and even bounded waiting.</p>\n<p>Drawbacks:</p>\n<ul>\n<li>busy-waiting (spinlocks)</li>\n<li>extra coding (e.g. to add bounded waiting)</li>\n</ul>\n<p>Advantage:</p>\n<ul>\n<li>avoid system calls</li>\n<li>can be more efficient if expected wait time is short</li>\n<li>only makes sense on multi-CPU/core systems</li>\n</ul>","frontmatter":{"date":"February 26, 2019","title":"More Synchronization Mechanisms","tags":["cpsc457"]}}},"pageContext":{"prev":{"fields":{"slug":"/cpsc457/lec10-semaphores-cv"},"frontmatter":{"published":true,"tags":["cpsc457"]}},"slug":"/cpsc457/lec11-more-synchronization","next":null,"category":"cpsc457"}}