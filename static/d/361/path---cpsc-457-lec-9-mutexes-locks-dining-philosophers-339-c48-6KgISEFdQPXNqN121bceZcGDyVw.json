{"data":{"markdownRemark":{"html":"<h2>'Dining Philosophers' Problem</h2>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e245f682dd85636724ea918eae956471/efba4/lec9-dining-philosophers.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 105.3968253968254%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAAD70lEQVQ4y5WU+0/TVxjG+zfshy3+ssEPJEtMDNvYiIHh5uzEKLWAuHJzDY6bXDJLi8SUwmADZ3SgDKjcAuU+IiCGNWwDFpBxlzKlOJCJDBSIjMvsHNDyWVtoFSpL9ibne3Le73mf87znPO8r4CW2sbFhHRYzGAxotVru3bvn8O9lJtjth9FotM79/f14enpSXl5uXZtMpv8PaAmwBFpsfHwcV1dXK0vbQf/FUrAzDdtsNK5vMhwYRJWahm747pZ/zWHvi/ECCxOTyWgd9g0m43O2689Ymptk4fHv27PYysCWjY25Q8o2sKX5Kfobz3NN6c3Z+ATOxUfRnOPPnXY16+vGrfs0OqY8NTVBSMCH5H97we58ONKORvk2NUmvESzyoLA0A1VGGinSvdxMeQVt3kmW/5yzg2o0GkpKSjYZJsnDCD28B6HHHn4bH+Pp3Ci1qn00Zb5FXsI+VNHHEEtiiY46Q3XaB5Qq3ahXvU63JsQKeKOpCRcXF7y8vOjs7EQQHHiMvW++wTuur9Lb00pNThKxn4XypSwI7eX36cg7SGW6iKZLR7mtEaNReZEpD+F8hA8zI60UFpfi7OyEj4/IKi1BQYEagUCAm/u7PNB3c0LsR21DFnEKpTn4EHdr/BiuFDNU4cv965+QEvkxX2QqSbuQQu7FdHq7O3Bycsbd3Z2urq7NR/m+uYmJyRmejLdyJtCb4DAZsrhoWq6KGTSz6i/zZ7AikJFKEdkKMQGhccQnyMhNCWPdMMdPbT+bC6DPUdgTA420XPYiPUpIXaaIoXI/bl07yq/ffYquKogBTSCj18MoTA0l++wR+sz3aFia21YQAstnfW3V6nh8v5fGjP1UpHrQmiNkoPS4Od0TVnbD1cGMVAVwu8yXG5eEdOYf4U6jnH/+NmAyY2zToU3Qz56u0KYO4Mfsg6TLpCTERFJ/0Rd9XRDDVRJylSHIYqLIkov4IesjRtty7dq1V8pm2TwX9LSuDqXUjc/PySitzSdGKqGvSEh1ujdBp6TUNxcSHnaaW+rjLD/5YytV03ZAWxexWUv1FbwP+3M6Op5vEk+iSd5PfcYBJAGnkEbEkhgp4ZG+3QHM/ig2ML1eT3Kyiubmm3S1NJCTKEb7tRsNX71H+xVP6tIOcFUVzdjwLywu/8XMzLQ9dhtDm1OhUBARHo5EYmYwO2v2rDE91sPEYCOTwy0sPtJvquHBQyrMIi4rK2NhYcER0LaQyxVERkbi6+uLTqfbtYn29vRQXFxMQUEBs9aDd2HY0dGBUCg0A8tZXV21F7+1tW3NFrOwUqvVFBUV2Tu7HfDFhcWGhoZYXFx0eKidTXV+fp6VlRV2xv8LMhBwjOSZc78AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"Philosophers\"\n        title=\"\"\n        src=\"/static/e245f682dd85636724ea918eae956471/fb8a0/lec9-dining-philosophers.png\"\n        srcset=\"/static/e245f682dd85636724ea918eae956471/1a291/lec9-dining-philosophers.png 148w,\n/static/e245f682dd85636724ea918eae956471/2bc4a/lec9-dining-philosophers.png 295w,\n/static/e245f682dd85636724ea918eae956471/fb8a0/lec9-dining-philosophers.png 590w,\n/static/e245f682dd85636724ea918eae956471/efba4/lec9-dining-philosophers.png 630w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n  </span>\n  </a></p>\n<p>There are 5 philosophers sitting around a table. Philosophers want to do 2 things, forever:</p>\n<ul>\n<li>eat, and then</li>\n<li>think</li>\n</ul>\n<p>There are 5 bowls of food, one for each philosophers &#x26; 5 forks placed between bowls. Before eating, a philosopher must grab two forks, immediately to the left &#x26; right. Philosopher then eats for a short time. When done eating, the philosopher puts down the forks in their original positions. Philosopher then thinks for a short time.</p>\n<p><strong>Software scenario</strong>:</p>\n<ul>\n<li>5 processes/threads, each needs exclusive access to two resources to proceed.</li>\n</ul>\n<p>How to allocate resources so that all processes/threads get to execute? What is the <strong>best</strong> algorithm for threads/processes to follow?</p>\n<p>Assuming each philosopher eats &#x26; thinks for the exact same amount of time, optimal schedule:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">repeat:\n  1 &amp; 3 eat\n  2 &amp; 4 eat\n  3 &amp; 5 eat\n  4 &amp; 1 eat\n  5 &amp; 2 eat</code></pre></div>\n<blockquote>\n<p>There is no solution for every case.</p>\n</blockquote>\n<hr>\n<p><strong>Attempt 1</strong>:</p>\n<p>Assuming that philosophers are \"perfectly synchronized\". Each philosopher follows these steps:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">repeat forever:\n  grab left fork\n  grab right fork\n  eat\n  put forks back\n  think</code></pre></div>\n<p>This would lead to a <mark><strong>deadlock</strong></mark>:</p>\n<ul>\n<li>assuming all philosophers are reasonably synchronized</li>\n<li>each philosopher will end up grabbing the left fork</li>\n<li>each philosopher will be stuck trying to grab the right fork</li>\n<li>nobody gets to eat at all</li>\n</ul>\n<p><strong>Attempt 2</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">repeat forever:\n  repeat:\n    try to grab left fork\n    try to grab right fork\n    if both forks grabbed:\n      break\n    else:\n      put any grabbed forks back and take a short nap\n  eat\n  put forks back\n  think</code></pre></div>\n<p>This would reach <mark><strong>livelock</strong></mark>:</p>\n<ul>\n<li>assuming they are all synchronized</li>\n<li>all philosophers will indefinitely switch switch between napping and attempting to eat</li>\n<li>nobody will eat - form of <strong>starvation</strong></li>\n</ul>\n<p><strong>Attempt 3</strong>:</p>\n<p>Same as before, but there is one pink hat that one philosopher is wearing</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">repeat forever:\n  wait for hat\n  grab forks, eat, put forks back\n  give hat to someone else\n  think</code></pre></div>\n<p>It would work, but:</p>\n<ul>\n<li>only one process get to eat</li>\n<li>but with 5 forks, 2 philosophers could be eating at the same time</li>\n<li>it defeats the purpose of multithreading (no parallelism of eating); not optimal use of resources</li>\n<li>called arbitrator solution</li>\n</ul>\n<p><strong>Attempt 4</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">while true:\n  repeat\n    try to grab left fork\n    try to grab right fork\n    if both forks grabbed:\n      break\n    else:\n      put any grabbed forks back\n      take a short **RANDOM** nap\n  eat\n  put forks back\n  think</code></pre></div>\n<p>We introduce a random <strong>timeout</strong> mechanism for preventing deadlocks. Likely to work, often used in real world, for example in networking. However, there is still a small chance for starvation:</p>\n<ul>\n<li>if sleep is the same for all philosophers, then no one gets to eat</li>\n<li>in some cases some philosophers might never get to eat, or some philosophers will get to eat less often than the others - <em>fairness problem</em></li>\n</ul>\n<p><strong>Attempt 5</strong>:</p>\n<ul>\n<li>Label the forks with numbers: 1, ..., 5</li>\n<li>\n<p>Each philosopher:</p>\n<ul>\n<li>picks up the fork with the smallest number first, then the larger number second</li>\n<li>if unable to pick up both forks, put a claimed fork down and take a short nap</li>\n</ul>\n</li>\n</ul>\n<p>This is a <strong>resource hierarchy</strong> solution - by establishing a <strong>partial order</strong> on resources. Starvation is still possible. Also not always practical for large/dynamic number of resources.</p>\n<hr>\n<p><strong>Naive algorithm implementation</strong>:</p>\n<p>Even trying to implement a naive solution presents problems. Consider algorithm for #1:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">/* \n  Utencil state: \n    true = available\n    false = unavailable\n*/</span>\nbool forks<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                          <span class=\"token comment\">// think for s seconds</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>forks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> forks<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// i + 1 % 5 arithmetic</span>\n  forks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span>\n  forks<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                          <span class=\"token comment\">// eat for m seconds</span>\n  forks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>\n  forks<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Depending on the execution order (e.g. multicore machines, or timing of context switches):</p>\n<ul>\n<li>both philosophers could start eating at the same time</li>\n<li>i.e. both processes could enter the critical region</li>\n</ul>\n<p>In that code, the shared resource is the global variable <code class=\"language-text\">forks[]</code>. The critical sections are:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">/* \n  Utencil state: \n    true = available\n    false = unavailable\n*/</span>\nbool forks<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>forks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> forks<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// critical section</span></span><span class=\"gatsby-highlight-code-line\">  forks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  forks<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span></span>  <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                          <span class=\"token comment\">// critical section</span>\n<span class=\"gatsby-highlight-code-line\">  forks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  forks<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span></span><span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Mutex (aka Lock)</h2>\n<p><strong>Mutex</strong> is a synchronization mechanism used for ensuring <strong>exclusive access</strong> to a resource in concurrent programs. Think of mutex as a special boolean type that can represent a lock:</p>\n<ul>\n<li><code class=\"language-text\">true</code> <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding=\"application/x-tex\">\\to</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">→</span></span></span></span> locked</li>\n<li><code class=\"language-text\">false</code> <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding=\"application/x-tex\">\\to</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">→</span></span></span></span> unlocked</li>\n</ul>\n<p>We can set it to <code class=\"language-text\">true</code> or <code class=\"language-text\">false</code> just like a regular boolean variable. But, if the lock is already locked, and some thread tries to also lock it, then the calling thread will be automatically suspended until whoever locked the lock, unlocks it.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">mutex lock<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Will block if already TRUE</span>\nlock <span class=\"token operator\">=</span> TRUE<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/*\n Critical section\n\n it is protected by the mutex lock\n*/</span>\n\n<span class=\"token comment\">// May unblock some other thread</span>\nlock <span class=\"token operator\">=</span> FALSE<span class=\"token punctuation\">;</span></code></pre></div>\n<!-- TODO: Finish mutex -->","frontmatter":{"date":"February 12, 2019","title":"Dining Philosophers, Locks, Mutexes","tags":["cpsc457"]}}},"pageContext":{"prev":{"fields":{"slug":"/cpsc413/lec2-algorithm-analysis"},"frontmatter":{"published":true,"tags":["cpsc413"]}},"slug":"/cpsc457/lec9-mutexes-locks-dining-philosophers","next":null,"category":"cpsc457"}}