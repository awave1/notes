{"data":{"allMarkdownRemark":{"totalCount":1,"edges":[{"node":{"id":"b5c98622-d97c-5450-b15d-e0b84823ed00","html":"<h2>'Dining Philosophers' Problem</h2>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/notes/static/e245f682dd85636724ea918eae956471/201dc/lec9-dining-philosophers.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 105.3968253968254%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAAD70lEQVQ4y5WU+0/TVxjG+zfshy3+ssEPJEtMDNvYiIHh5uzEKLWAuHJzDY6bXDJLi8SUwmADZ3SgDKjcAuU+IiCGNWwDFpBxlzKlOJCJDBSIjMvsHNDyWVtoFSpL9ibne3Le73mf87znPO8r4CW2sbFhHRYzGAxotVru3bvn8O9lJtjth9FotM79/f14enpSXl5uXZtMpv8PaAmwBFpsfHwcV1dXK0vbQf/FUrAzDdtsNK5vMhwYRJWahm747pZ/zWHvi/ECCxOTyWgd9g0m43O2689Ymptk4fHv27PYysCWjY25Q8o2sKX5Kfobz3NN6c3Z+ATOxUfRnOPPnXY16+vGrfs0OqY8NTVBSMCH5H97we58ONKORvk2NUmvESzyoLA0A1VGGinSvdxMeQVt3kmW/5yzg2o0GkpKSjYZJsnDCD28B6HHHn4bH+Pp3Ci1qn00Zb5FXsI+VNHHEEtiiY46Q3XaB5Qq3ahXvU63JsQKeKOpCRcXF7y8vOjs7EQQHHiMvW++wTuur9Lb00pNThKxn4XypSwI7eX36cg7SGW6iKZLR7mtEaNReZEpD+F8hA8zI60UFpfi7OyEj4/IKi1BQYEagUCAm/u7PNB3c0LsR21DFnEKpTn4EHdr/BiuFDNU4cv965+QEvkxX2QqSbuQQu7FdHq7O3Bycsbd3Z2urq7NR/m+uYmJyRmejLdyJtCb4DAZsrhoWq6KGTSz6i/zZ7AikJFKEdkKMQGhccQnyMhNCWPdMMdPbT+bC6DPUdgTA420XPYiPUpIXaaIoXI/bl07yq/ffYquKogBTSCj18MoTA0l++wR+sz3aFia21YQAstnfW3V6nh8v5fGjP1UpHrQmiNkoPS4Od0TVnbD1cGMVAVwu8yXG5eEdOYf4U6jnH/+NmAyY2zToU3Qz56u0KYO4Mfsg6TLpCTERFJ/0Rd9XRDDVRJylSHIYqLIkov4IesjRtty7dq1V8pm2TwX9LSuDqXUjc/PySitzSdGKqGvSEh1ujdBp6TUNxcSHnaaW+rjLD/5YytV03ZAWxexWUv1FbwP+3M6Op5vEk+iSd5PfcYBJAGnkEbEkhgp4ZG+3QHM/ig2ML1eT3Kyiubmm3S1NJCTKEb7tRsNX71H+xVP6tIOcFUVzdjwLywu/8XMzLQ9dhtDm1OhUBARHo5EYmYwO2v2rDE91sPEYCOTwy0sPtJvquHBQyrMIi4rK2NhYcER0LaQyxVERkbi6+uLTqfbtYn29vRQXFxMQUEBs9aDd2HY0dGBUCg0A8tZXV21F7+1tW3NFrOwUqvVFBUV2Tu7HfDFhcWGhoZYXFx0eKidTXV+fp6VlRV2xv8LMhBwjOSZc78AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"Philosophers\"\n        title=\"\"\n        src=\"/notes/static/e245f682dd85636724ea918eae956471/623ee/lec9-dining-philosophers.png\"\n        srcset=\"/notes/static/e245f682dd85636724ea918eae956471/816c5/lec9-dining-philosophers.png 148w,\n/notes/static/e245f682dd85636724ea918eae956471/c766b/lec9-dining-philosophers.png 295w,\n/notes/static/e245f682dd85636724ea918eae956471/623ee/lec9-dining-philosophers.png 590w,\n/notes/static/e245f682dd85636724ea918eae956471/201dc/lec9-dining-philosophers.png 630w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n  </span>\n  </a></p>\n<p>There are 5 philosophers sitting around a table. Philosophers want to do 2 things, forever:</p>\n<ul>\n<li>eat, and then</li>\n<li>think</li>\n</ul>\n<p>There are 5 bowls of food, one for each philosophers &#x26; 5 forks placed between bowls. Before eating, a philosopher must grab two forks, immediately to the left &#x26; right. Philosopher then eats for a short time. When done eating, the philosopher puts down the forks in their original positions. Philosopher then thinks for a short time.</p>\n<p><strong>Software scenario</strong>:</p>\n<ul>\n<li>5 processes/threads, each needs exclusive access to two resources to proceed.</li>\n</ul>\n<p>How to allocate resources so that all processes/threads get to execute? What is the <strong>best</strong> algorithm for threads/processes to follow?</p>\n<p>Assuming each philosopher eats &#x26; thinks for the exact same amount of time, optimal schedule:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">repeat:\n  1 &amp; 3 eat\n  2 &amp; 4 eat\n  3 &amp; 5 eat\n  4 &amp; 1 eat\n  5 &amp; 2 eat</code></pre></div>\n<blockquote>\n<p>There is no solution for every case.</p>\n</blockquote>\n<hr>\n<p><strong>Attempt 1</strong>:</p>\n<p>Assuming that philosophers are \"perfectly synchronized\". Each philosopher follows these steps:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">repeat forever:\n  grab left fork\n  grab right fork\n  eat\n  put forks back\n  think</code></pre></div>\n<p>This would lead to a <mark><strong>deadlock</strong></mark>:</p>\n<ul>\n<li>assuming all philosophers are reasonably synchronized</li>\n<li>each philosopher will end up grabbing the left fork</li>\n<li>each philosopher will be stuck trying to grab the right fork</li>\n<li>nobody gets to eat at all</li>\n</ul>\n<p><strong>Attempt 2</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">repeat forever:\n  repeat:\n    try to grab left fork\n    try to grab right fork\n    if both forks grabbed:\n      break\n    else:\n      put any grabbed forks back and take a short nap\n  eat\n  put forks back\n  think</code></pre></div>\n<p>This would reach <mark><strong>livelock</strong></mark>:</p>\n<ul>\n<li>assuming they are all synchronized</li>\n<li>all philosophers will indefinitely switch switch between napping and attempting to eat</li>\n<li>nobody will eat - form of <strong>starvation</strong></li>\n</ul>\n<p><strong>Attempt 3</strong>:</p>\n<p>Same as before, but there is one pink hat that one philosopher is wearing</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">repeat forever:\n  wait for hat\n  grab forks, eat, put forks back\n  give hat to someone else\n  think</code></pre></div>\n<p>It would work, but:</p>\n<ul>\n<li>only one process get to eat</li>\n<li>but with 5 forks, 2 philosophers could be eating at the same time</li>\n<li>it defeats the purpose of multithreading (no parallelism of eating); not optimal use of resources</li>\n<li>called arbitrator solution</li>\n</ul>\n<p><strong>Attempt 4</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">while true:\n  repeat\n    try to grab left fork\n    try to grab right fork\n    if both forks grabbed:\n      break\n    else:\n      put any grabbed forks back\n      take a short **RANDOM** nap\n  eat\n  put forks back\n  think</code></pre></div>\n<p>We introduce a random <strong>timeout</strong> mechanism for preventing deadlocks. Likely to work, often used in real world, for example in networking. However, there is still a small chance for starvation:</p>\n<ul>\n<li>if sleep is the same for all philosophers, then no one gets to eat</li>\n<li>in some cases some philosophers might never get to eat, or some philosophers will get to eat less often than the others - <em>fairness problem</em></li>\n</ul>\n<p><strong>Attempt 5</strong>:</p>\n<ul>\n<li>Label the forks with numbers: 1, ..., 5</li>\n<li>\n<p>Each philosopher:</p>\n<ul>\n<li>picks up the fork with the smallest number first, then the larger number second</li>\n<li>if unable to pick up both forks, put a claimed fork down and take a short nap</li>\n</ul>\n</li>\n</ul>\n<p>This is a <strong>resource hierarchy</strong> solution - by establishing a <strong>partial order</strong> on resources. Starvation is still possible. Also not always practical for large/dynamic number of resources.</p>\n<hr>\n<p><strong>Naive algorithm implementation</strong>:</p>\n<p>Even trying to implement a naive solution presents problems. Consider algorithm for #1:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">/* \n  Utencil state: \n    true = available\n    false = unavailable\n*/</span>\nbool forks<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                          <span class=\"token comment\">// think for s seconds</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>forks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> forks<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// i + 1 % 5 arithmetic</span>\n  forks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span>\n  forks<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                          <span class=\"token comment\">// eat for m seconds</span>\n  forks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>\n  forks<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Depending on the execution order (e.g. multicore machines, or timing of context switches):</p>\n<ul>\n<li>both philosophers could start eating at the same time</li>\n<li>i.e. both processes could enter the critical region</li>\n</ul>\n<p>In that code, the shared resource is the global variable <code class=\"language-text\">forks[]</code>. The critical sections are:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">/* \n  Utencil state: \n    true = available\n    false = unavailable\n*/</span>\nbool forks<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>forks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> forks<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// critical section</span></span><span class=\"gatsby-highlight-code-line\">  forks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  forks<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span></span>  <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                          <span class=\"token comment\">// critical section</span>\n<span class=\"gatsby-highlight-code-line\">  forks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  forks<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span></span><span class=\"token punctuation\">}</span></code></pre></div>\n<hr>\n<h2>Mutex (aka Lock)</h2>\n<p><strong>Mutex</strong> is a synchronization mechanism used for ensuring <strong>exclusive access</strong> to a resource in concurrent programs. Think of mutex as a special boolean type that can represent a lock:</p>\n<ul>\n<li><code class=\"language-text\">true</code> <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding=\"application/x-tex\">\\to</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">→</span></span></span></span> locked</li>\n<li><code class=\"language-text\">false</code> <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding=\"application/x-tex\">\\to</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">→</span></span></span></span> unlocked</li>\n</ul>\n<p>We can set it to <code class=\"language-text\">true</code> or <code class=\"language-text\">false</code> just like a regular boolean variable. But, if the lock is already locked, and some thread tries to also lock it, then the calling thread will be automatically suspended until whoever locked the lock, unlocks it.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">mutex lock<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Will block if already TRUE</span>\nlock <span class=\"token operator\">=</span> TRUE<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/*\n Critical section\n\n it is protected by the mutex lock\n*/</span>\n\n<span class=\"token comment\">// May unblock some other thread</span>\nlock <span class=\"token operator\">=</span> FALSE<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Mutex is often implemented as an object with two possible states: <em>locked</em> and <em>unlocked</em>. It implements two operations <code class=\"language-text\">lock()</code> and <code class=\"language-text\">unlock()</code>. If multiple threads call <code class=\"language-text\">lock()</code> simultaneously, only one will proceed, the others will block. Therefore, only the thread <em>that locks</em> the mutes can <em>unlock it</em>.</p>\n<p>A waiting queue is used to keep track of all threads waiting on the mutex to be unlocked. Once the mutex is unlocked, one of the blocked threads will be unlocked. <em>Note</em>: which one thread gets unlocked is usually not predictable. It can be implemented in software via busy waiting, but usually supported by hardware + OS. Portable libraries often try to use H/W mutex but are able to fall back to software.</p>\n<h3>Mutex in pthread</h3>\n<table>\n<thead>\n<tr>\n<th>API</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">pthread_mutex_init()</code></td>\n<td>create a mutex</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">pthread_mutex_destroy()</code></td>\n<td>destroy a mutex</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">pthread_mutex_lock()</code></td>\n<td>lock a mutex, block if already locked</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">pthread_mutex_trylock()</code></td>\n<td>lock a mutex, or fail (non-blocking version)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">pthread_mutex_unlock()</code></td>\n<td>unlock a mutex</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Counter with mutex</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;pthread.h></span></span>\n\n<span class=\"token comment\">// initialized in main() with pthread_mutex_init()</span>\npthread_mutex_t count_mutex<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// initialized in main() with counter = 0</span>\n<span class=\"token keyword\">int</span> counter<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">incr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// acquire the lock</span>\n  <span class=\"token function\">pthread_mutex_lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>count_mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> counter<span class=\"token punctuation\">;</span>\n  x<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  counter <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// release the lock</span>\n  <span class=\"token function\">pthread_mutex_unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>count_mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Dining philosopher with mutex</strong>:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"c\"><pre style=\"counter-reset: linenumber 0\" class=\"language-c line-numbers\"><code class=\"language-c\">pthread_mutex_t mutex<span class=\"token punctuation\">;</span>\nbool forks<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token function\">pthread_mutex_lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>forks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> forks<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  forks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  forks<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token function\">pthread_mutex_unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>\n  <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token function\">pthread_mutex_lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  forks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  forks<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token function\">pthread_mutex_unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>However, this will not work, due to <strong>deadlock</strong>. <code class=\"language-text\">while (!forks[i] || forks[i + 1]);</code> will result in an infinite loop. It can also be argued that this is a <strong>livelock</strong>.</p>\n<hr>\n<h2>Summary</h2>\n<ul>\n<li><strong>Critical section</strong> - part of the program where a shared resource is accessed &#x26; may cause trouble</li>\n<li><strong>Mutual exclusion</strong> - ensuring only one process accesses a resource at a time, e.g. only one process can enter critical section at a time</li>\n<li><strong>Mutex/lock</strong> - mechanism to achieve mutual exclusion, two states + queue</li>\n<li><strong>Deadlock</strong> - a state where each process/thread is waiting on another to release a lock <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding=\"application/x-tex\">\\to</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">→</span></span></span></span> no progress is made</li>\n<li><strong>Livelock</strong> - states of the process change, but none are progressing</li>\n<li><strong>Starvation</strong> - one process does not get to run at all</li>\n<li><strong>Unfairness</strong> - not all processes get equal opportunity to progress</li>\n<li>\n<p>There are some thread issues:</p>\n<ul>\n<li><code class=\"language-text\">fork()</code>, cancellation, signals, thread pool</li>\n<li>race conditions</li>\n<li>critical section, mutual exclusion</li>\n<li>dining philosophers problem</li>\n<li>mutex</li>\n<li>deadlock, livelock, starvation, fairness</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"Dining Philosophers, Locks, Mutexes","date":"2019-02-12","description":""},"fields":{"slug":"/cpsc457/lec9-mutexes-locks-dining-philosophers","category":"cpsc457"}}}]}},"pageContext":{"tag":"concurrency"}}