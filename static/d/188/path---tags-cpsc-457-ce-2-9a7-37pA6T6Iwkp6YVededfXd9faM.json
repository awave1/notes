{"data":{"allMarkdownRemark":{"totalCount":2,"edges":[{"node":{"id":"dfff0736-3c0b-51c2-8d28-2810c0ee4dd7","html":"<h2>Hardware Review</h2>\n<p>A typical computer contains of several components that are interconnected through a bus.</p>\n<h3>CPU</h3>\n<p>CPU is the \"brain\" of the computer. It contains different types of registers (registers - very fast memory):</p>\n<ul>\n<li>\n<p>On-board registers for faster computation.</p>\n<ul>\n<li>Instead of accessing memory for every instruction</li>\n<li>Accessing information in registers is faster than memory</li>\n</ul>\n</li>\n<li>\n<p>General purpose registers</p>\n<ul>\n<li>Data &#x26; address</li>\n</ul>\n</li>\n</ul>\n<!--TODO: Finish-->\n<p>A simple CPU cycle:</p>\n<ol>\n<li><strong>Fetch</strong> an instruction</li>\n<li><strong>Decode</strong> it to determine its type and operands</li>\n<li><strong>Execute</strong> it</li>\n</ol>\n<p>Steps are repeated for the next instruction, until program finishes.</p>\n<p>However, there is a performance issue: fetching from memory takes longer than executing an instruction. A solution would be to <strong>pipeline</strong> the opertaions:</p>\n<h4>CPU Pipelining</h4>\n<ul>\n<li>while executing instruction <code class=\"language-text\">N</code>,</li>\n<li>the CPU could be simultaneously decoding instruction <code class=\"language-text\">N + 1</code>,</li>\n<li>and at the same time also fetch instruction <code class=\"language-text\">N + 2</code></li>\n</ul>\n<p>Therefore fetch-execute cycle can be done in parallel. Three stage pipeline:</p>\n<div class=\"gatsby-highlight\" data-language=\"mermaid-svg\"><pre class=\"language-mermaid-svg\"><code class=\"language-mermaid-svg\">graph LR\n  A[Fetch Unit]--&gt;B[Decode Unit]\n  B--&gt;C[Execute Unit]</code></pre></div>\n<!--TODO: Finish-->\n<!--parallelized app will be as fast as slowest link of the pipeline-->\n<h3>Memory</h3>\n<p>Ideally, memory should be (i) fast, (ii) large and (iii) cheap. In practice, we can get 2 out of 3, but not all three.</p>\n<p>Main memory is RAM (Random Access Memory). Memory is a accessible big array of bytes. Memory operations:</p>\n<ul>\n<li><strong>load</strong>: moves a word from memory to a CPU register</li>\n<li><strong>store</strong>: moves a content of a register to memory</li>\n</ul>\n<p>Both load and store operations are slow compared to the speed of CPU.</p>\n<h2>Caching</h2>\n<p>CPU caching is the process of most heavily used data from memory is kept in a high-speed cache inside or very close to the CPU. When CPU needs to get data from memory, it first checks the cache:</p>\n<ul>\n<li>\n<p><strong>cache hit</strong>: the data needed by the CPU is in the cache</p>\n  <!--or-->\n</li>\n<li><strong>cache miss</strong>: CPU needs to fetch the data from main memory</li>\n</ul>\n<p>CPU consists of multiple levels of caches:</p>\n<ul>\n<li>L1 cache (16kB): inside the CPU, usually feeds decoded instructions into CPU execution engine</li>\n<li>L2 cache (xMB): stores recently used memory words, slower than L1</li>\n<li>L3 and L4 are becoming common</li>\n</ul>\n<!--core is like a mini cpu-->\n<h3>Caching on multicore CPUs</h3>\n<!-- TODO: image -->\n<!--1. can process bigger chunks, bigger parts of the memory because L2 will be bigger-->\n<p>Caches can be shared and there are multiple ways of sharing cache.</p>\n<hr>\n<p>The goal of caching is to increase performance of slower memory/device by adding a small amount of fast memory (cache). Ways of improving read performance:</p>\n<ul>\n<li>keep copy of information obtained from slow storage in cache</li>\n<li>check cache on next read</li>\n</ul>\n<p>Improving write performance:</p>\n<ul>\n<li>write info to fast storage, and eventually write to slow storage</li>\n</ul>\n<p>Caching is a very useful concept. There are many uses: disk cache, DNS, databases.</p>\n<p>Cache storage is fast but expensive, so it's usually much smaller than the slow storage. Some general caching issues:</p>\n<ul>\n<li>when to put a new item into the cache</li>\n<li>which cache line to put the new item in</li>\n<li>which item to remove from the cache when it's full</li>\n<li>where to put a newly evicted item in the larger memory</li>\n<li>multiple cache synchronization</li>\n<li>how long is the data in cache valid</li>\n</ul>\n<h3>Memoization</h3>\n<p>It's a similar concept to caching. It can be used to speed up function that are slow to compute. Optimization technique used to speed up programs, by storing results of expensive computations.</p>\n<p>Unoptimized function:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">fib_slow</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  <span class=\"token keyword\">if</span> n <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> n\n  <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> fib_slow<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> fib_slow<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Optimized function:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">cache <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">fib_fast</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  <span class=\"token keyword\">if</span> n <span class=\"token operator\">not</span> <span class=\"token keyword\">in</span> cache<span class=\"token punctuation\">.</span>keys<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> n <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n      cache<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> n\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n      cache<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> fib_fast<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> fib_fast<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">return</span> cache<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span></code></pre></div>\n<h2>Hardware I/O</h2>\n<p>I/O devices usually implemented in two parts: device controller and the device.</p>\n<p>A <strong>device controller</strong> is a chip or a set of chips that physically control the device. Controlling the device is complicated, and CPU could be doing other things, so the controller presents a simpler interface to the OS. A controller presents a unified interface of devices that it can support to the OS.</p>\n<p>A <strong>device</strong> connects to the computer through the controller. It follows some agreed standards for communication.</p>\n<p>A <strong>device driver</strong> is the software abstraction of the controller, the software that talks to a controller, issues commands and accepts responses. Usually is written by the manufacturer. Driver is needed so the OS knows how to communicate with the device.</p>\n<h2>Buses</h2>\n<p><strong>Bus</strong> is a communication system for transferring data between different computer components.</p>\n<h2>Booting Process</h2>\n<p>When the computer is booted, the BIOS is started. BIOS (Basic Input Output Program) is a program stored on motherboard.</p>\n<h2>Kernel</h2>\n<p>The central part, or the heart of the OS. Kernel is running at all times on the computer. It is located and started by a bootstrap program (bootloader). Kernel provides services to applications via system calls and handles all interrupts. Much of kernel is a set of routines, some invoked in response to interrupts, others because of application using system calls, etc.</p>\n<h3>Kernel mode</h3>\n<!--not all kernel runs in kernel mode-->\n<p>When CPU is in kernel mode, every instruction are executed.</p>\n<h3>User mode</h3>\n<!--true-->\n<!--true-->\n<!--most run in kernel, but some are in user mode-->","frontmatter":{"title":"Hardware, Cache, Booting, Kernel","date":"2019-01-17","description":""},"fields":{"slug":"/cpsc457/lec2-hardware-cache","category":"cpsc457"}}},{"node":{"id":"25b45286-48c7-592a-be74-3f2f739da7ed","html":"<h2>Defining an OS</h2>\n<p>There's no 'precise' definition. It is a layer of software that provides application programs with a better, simpler, cleaner model of the computer. The OS is there to simplify interaction with the hardware. OS manages all resources.</p>\n<p>It is the software that runs all the time (mostly in kernel mode). All other applications need it in order to run (<em>most</em> applications will need it).</p>\n<p>We can look at an OS from two different perspectives:</p>\n<ul>\n<li>an <strong>extended machine</strong></li>\n<li>as a <strong>resource manager</strong></li>\n</ul>\n<p>An OS presents an abstraction mechanism that lets you interact with the hardware.</p>\n<h3>OS - an extended machine</h3>\n<p>Abstraction / generalization is key to managing complexity. First we define and implement the abstractions. For example, files - working with files is easier than dealing with raw disk space. Then, using these abstractions, we write applications and solve problems (e.g. file editor, image viewer). An OS doesn't care what's in the file, it is up to the applications to determine how to use the file.</p>\n<p>The abstractions allow us to mask the ugly hardware and provide nice interfaces instead. Many OS concepts are abstractions, therefore there are some similarities to OOP.</p>\n<h3>OS - a resource manager</h3>\n<p>OS acts as a resource allocator. It multiplexes available resources.</p>\n<ul>\n<li>\n<p>Multiplexing resources in time</p>\n<ul>\n<li>e.g. 3 programs trying to print to the same printer (spooling)</li>\n<li>e.g. 2 programs trying to run at the same time (scheduling)</li>\n</ul>\n</li>\n<li>\n<p>Multiplexing resources in space</p>\n<ul>\n<li>e.g. 2 programs allocating memory</li>\n</ul>\n</li>\n</ul>\n<p>OS manages conflics among multiple programs or users.</p>\n<!--IMPORTANT: syscalls need to be checked-->\n<p>We can also think about OS as a control program. It decides when to run which application. OS monitors improper use and prevents errors. OS is responsible for handling all interrupts and traps.</p>\n<h2>History of Operating Systems</h2>\n<p>OSes often developed by customers instead of HW manufacturers. IBM developed first OS in the 60's.</p>\n<h3>First Generation (1945 - 1955): Vacuum Tubes and no OS</h3>\n<p>Programs were hardwired, later were made on punch cards. Programs were written in machine language. Hardware required complicated wiring. Only single user at a time. Such computers were only able to perform basic calculations. No OS since there was no need for one.</p>\n<h3>Second Generation (1955 - 1965): Transistors and Batch Systems</h3>\n<p>Transistor based mainframe computers replaced old vacuum tube computers. Programs were made with FORTRAN &#x26; COBOL. OSes that were used: FMS (Fortran Monitor System) and IBSYS (IBM OS). Important concept was introduced: <strong>batch systems</strong>.</p>\n<h4>Batch Systems</h4>\n<p>The users of a batch operating system do not interact with the computer directly. Each user prepares his job on an off-line device like punch cards and submits it to the computer operator. To speed up processing, jobs with similar needs are batched together and run as a group. The programmers leave their programs with the operator and the operator then sorts the programs with similar requirements into batches.</p>\n<h3>Third Generation (1965 - 1980): ICs and Multiprogramming</h3>\n<p>Transistors were replaces with Integrated Circuits (ICs). Lots of OSes came out: IBM OS/360, CTSS (by MIT), MULTICS (complicated, but influential), UNIX (inspired by MULTICS). Important concepts:</p>\n<ul>\n<li><strong>multiprogramming</strong>: a different job in each memory partition, CPU execute other jobs, while waiting for the IO of some jobs. Multiple programs could sit in memory.</li>\n<li><strong>spooling</strong> (Simultaneous Peripheral Operation On Line): read jobs from cards to disk, load jobs from disk automatically, no more tapes.</li>\n<li><strong>time-sharing</strong>: multiple users using one computer simultaneously and interactively. Terminals were connected to a central server.</li>\n</ul>\n<h4>Multiprogramming</h4>\n<p>Refers to the idea, if you have more than one program in the memory, processor will switch between the programs when one program is idle.</p>\n<h4>Spooling</h4>\n<p>Spooling is typically used to deal with slow devices/peripherals, e.g. printer. Spooling can be used to deal (somewhat) with deadlocks in concurrent programming.</p>\n<h3>Fourth Generation (1990 - Now): Personal Computers</h3>\n<p>Cheap, mass-produced computers, User friendly interfaces on top of OS.</p>","frontmatter":{"title":"Operating Systems: Introduction, History, Basic Concepts","date":"2019-01-15","description":""},"fields":{"slug":"/cpsc457/lec1-basic-concepts","category":"cpsc457"}}}]}},"pageContext":{"tag":"cpsc457"}}