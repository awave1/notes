{"version":3,"sources":["webpack:///./src/utils/utils.js","webpack:///./src/pages/tags.js"],"names":["countWords","html","match","replace","count","i","length","charCodeAt","countImages","module","exports","leKebab","str","getReadingTime","wordCount","imageCount","contentCount","readingTime","readingTimeSeconds","Math","max","round","estimatedReadingTime","flatten","arr","concat","apply","unique","filter","el","array","indexOf","Tag","styled","li","pageQuery","TagsPage","data","group","allMarkdownRemark","title","site","siteMetadata","style","listStyle","margin","padding","map","tag","key","fieldValue","to","totalCount"],"mappings":"oGAQA,IAUMA,EAAa,SAAAC,GACjB,IAGMC,GAHOD,EAAOA,EAAKE,QAAQ,cAAe,KAAO,IAGpCD,MADH,oHAEZE,EAAQ,EAEZ,GAAc,OAAVF,EACF,OAAOE,EAGT,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAMI,OAAQD,IAC5BH,EAAMG,GAAGE,WAAW,IAAM,MAC5BH,GAASF,EAAMG,GAAGC,OAElBF,GAAS,EAIb,OAAOA,GAWHI,EAAc,SAAAP,GAAI,OAAIA,GAAQA,EAAKC,MAAM,mBAAqB,IAAII,OAAS,GAyCjFG,EAAOC,QAAU,CACfC,QAlFc,SAAAC,GAAG,OAAIA,EAAIT,QAAQ,mBAAoB,IAAIA,QAAQ,MAAO,MAmFxEU,eAbqB,SAAAZ,GAAS,IAAD,EA5BV,SAAAA,GAAI,MAAK,CAC5Ba,UAAWd,EAAWC,GACtBc,WAAYP,EAAYP,IA2BUe,CAAaf,GACzCgB,EAlBqB,SAACH,EAAWC,GACvC,IAEIG,EAAqBJ,GAFF,IACiB,IAGxC,GAAIC,EACF,IAAK,IAAIV,EAAI,GAAIA,EAAI,GAAKU,EAAYV,IACpCa,GAAsBC,KAAKC,IAAIf,EAAG,GAMtC,OAF2Bc,KAAKE,MAAMH,EAAqB,IAOvCI,CAFS,EACrBR,UADqB,EACVC,YAGnB,OAAOE,GAAe,EAAI,aAAkBA,EAArC,aAUPM,QAPc,SAAAC,GAAG,MAAI,GAAGC,OAAOC,MAAM,GAAIF,IAQzCG,OANa,SAAAH,GAAG,OAAIA,EAAII,QAAO,SAACC,EAAIxB,EAAGyB,GAAR,OAAkBA,EAAMC,QAAQF,KAAQxB,Q,kCCvFzE,0HAMM2B,EAAMC,IAAOC,GAAV,+DAAGD,CAAH,iDAgCIE,EAAS,aAgBPC,UA3CE,SAAC,GAOX,IAAD,IANJC,KACuBC,EAKnB,EALFC,kBAAqBD,MAEHE,EAGhB,EAJFC,KACEC,aAAgBF,MAIpB,OACE,6BACE,kBAAC,SAAD,CAAQA,MAAOA,IACf,6BACE,oCACA,wBAAIG,MAAO,CAAEC,UAAW,OAAQC,OAAQ,EAAGC,QAAS,IACjDR,EAAMS,KAAI,SAAAC,GAAG,OACZ,kBAAChB,EAAD,CAAKiB,IAAKD,EAAIE,YACZ,kBAAC,OAAD,CAAMC,GAAE,SAAWxC,kBAAQqC,EAAIE,YAAvB,KACLF,EAAIE,WADP,KACqBF,EAAII,WADzB","file":"component---src-pages-tags-js-52d532164de608499c73.js","sourcesContent":["/**\n * Format string to-kebab-format\n *\n * @param {string} str\n * @returns {integer} word count\n * @description Takes a html string and returns the number of images\n * Note: This code is taken from @tryghost/helpers package\n **/\nconst leKebab = str => str.replace(/[^A-Za-z0-9\\s]+/g, '').replace(/\\s/g, '-');\n\n/**\n * Word count utility\n *\n * @param {string} html string\n * @returns {integer} word count\n * @description Takes a html string and returns the number of words after sanitizing any html\n * Note: This code is taken from @tryghost/helpers package\n **/\nconst countWords = html => {\n  const text = html ? html.replace(/<(.|\\n)*?>/g, ' ') : ''; // strip any HTML tags\n\n  const pattern = /[a-zA-ZÀ-ÿ0-9_\\u0392-\\u03c9\\u0410-\\u04F9]+|[\\u4E00-\\u9FFF\\u3400-\\u4dbf\\uf900-\\ufaff\\u3040-\\u309f\\uac00-\\ud7af]+/g;\n  const match = text.match(pattern);\n  let count = 0;\n\n  if (match === null) {\n    return count;\n  }\n\n  for (let i = 0; i < match.length; i++) {\n    if (match[i].charCodeAt(0) >= 0x4e00) {\n      count += match[i].length;\n    } else {\n      count += 1;\n    }\n  }\n\n  return count;\n};\n\n/**\n * Image count utility\n *\n * @param {string} html string\n * @returns {integer} word count\n * @description Takes a html string and returns the number of images\n * Note: This code is taken from @tryghost/helpers package\n **/\nconst countImages = html => html ? (html.match(/<img(.|\\n)*?>/g) || []).length : 0;\n\nconst contentCount = html => ({\n  wordCount: countWords(html),\n  imageCount: countImages(html),\n});\n\n/**\n * Estimated reading time (based on medium https://blog.medium.com/read-time-and-you-bc2048ab620c)\n *\n * @param {integer} wordCount\n * @param {integer} imageCount\n * @returns {integer} estimated reading time in seconds\n **/\nconst estimatedReadingTime = (wordCount, imageCount) => {\n  const wordsPerMinute = 275;\n  const wordsPerSecond = wordsPerMinute / 60;\n  let readingTimeSeconds = wordCount / wordsPerSecond;\n\n  if (imageCount) {\n    for (let i = 12; i > 12 - imageCount; i--) {\n      readingTimeSeconds += Math.max(i, 3);\n    }\n  }\n\n  const readingTimeMinutes = Math.round(readingTimeSeconds / 60);\n\n  return readingTimeMinutes;\n};\n\nconst getReadingTime = html => {\n  const { wordCount, imageCount } = contentCount(html);\n  const readingTime = estimatedReadingTime(wordCount, imageCount);\n\n  return readingTime <= 1 ? '1 min read' : `${readingTime} min read`;\n};\n\nconst flatten = arr => [].concat.apply([], arr);\n\nconst unique = arr => arr.filter((el, i, array) => array.indexOf(el) === i);\n\nmodule.exports = {\n  leKebab,\n  getReadingTime,\n  flatten,\n  unique,\n};\n","import React from 'react';\nimport { Link, graphql } from 'gatsby';\nimport { Helmet } from 'react-helmet';\nimport styled from 'styled-components';\nimport { leKebab } from '../utils/utils';\n\nconst Tag = styled.li`\n  margin: 1rem 0;\n  font-family: 'Hack', monospace;\n`;\n\nconst TagsPage = ({\n  data: {\n    allMarkdownRemark: { group },\n    site: {\n      siteMetadata: { title },\n    },\n  },\n}) => {\n  return (\n    <div>\n      <Helmet title={title} />\n      <div>\n        <h3>Tags</h3>\n        <ul style={{ listStyle: 'none', margin: 0, padding: 0 }}>\n          {group.map(tag => (\n            <Tag key={tag.fieldValue}>\n              <Link to={`/tags/${leKebab(tag.fieldValue)}/`}>\n                {tag.fieldValue} ({tag.totalCount})\n              </Link>\n            </Tag>\n          ))}\n        </ul>\n      </div>\n    </div>\n  );\n};\n\nexport const pageQuery = graphql`\n  query {\n    site {\n      siteMetadata {\n        title\n      }\n    }\n    allMarkdownRemark(limit: 2000) {\n      group(field: frontmatter___tags) {\n        fieldValue\n        totalCount\n      }\n    }\n  }\n`;\n\nexport default TagsPage;\n"],"sourceRoot":""}