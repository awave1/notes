{"componentChunkName":"component---src-pages-index-js","path":"/","webpackCompilationHash":"df35e0c9a552e4f99013","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"430052fc-bb38-575a-af3b-476fc8bfe8b7","html":"<!--Content-->","frontmatter":{"date":"September 11, 2019","title":"Refactoring & Version Control","description":"","published":false},"fields":{"slug":"/cpsc501/refactoring-and-version-control","category":"cpsc501"}}},{"node":{"id":"ddfe3a47-d094-533e-b63c-2220dcedeb5a","html":"<!-- TODO: Finish lec02 -->\n<h2>Nomenclature</h2>\n<ul>\n<li>Asset</li>\n<li>Vulnerability</li>\n<li>Threat</li>\n<li>Attack</li>\n<li>Control</li>\n</ul>","frontmatter":{"date":"September 11, 2019","title":"Principles of Computer Security","description":"","published":false},"fields":{"slug":"/cpsc525/lec2","category":"cpsc525"}}},{"node":{"id":"5c03e963-8850-5a39-a964-6363dc4f295b","html":"<h2>Design Process</h2>\n<h3>Analysis Stage</h3>\n<p>Steps performed:</p>\n<ul>\n<li>Study existing system</li>\n<li>Meet with user groups</li>\n<li>Analyze existing procedures</li>\n<li>Modification to improve efficiency</li>\n<li>Prepare the initial proposal</li>\n</ul>\n<h4>Definition of Problem</h4>\n<ul>\n<li>To define a problem, develop a rough outline and scope the project.</li>\n<li>After the project is scoped, select an approach and determine its feasibility.</li>\n<li>\n<p>Estimate costs;</p>\n<ul>\n<li>initial setup</li>\n<li>operational</li>\n<li>risks versus benefits</li>\n</ul>\n</li>\n<li>Estimate time required for each part of the cycle</li>\n</ul>\n<h4>Existing System/Procedures Analysis</h4>\n<p>Analysis of the existing system is <strong>critical</strong>.</p>\n<ul>\n<li>Consider the way the things are done currently. Consider things to be present in current state of business.</li>\n<li>If possible, design the new system to <strong>minimize impact</strong>.</li>\n<li>Ask questions and talk to everyone you can.</li>\n<li>Determine any <em>sacred cow</em> and be very careful. Things like that need to be protected, because people care about those.</li>\n<li>\n<p>Find any:</p>\n<ul>\n<li>inefficiencies</li>\n<li>duplications</li>\n<li>procedural changes required</li>\n<li>how the new system will affect existing procedures</li>\n</ul>\n</li>\n<li>\n<p>Define explicitly the new systems requirements, including:</p>\n<ul>\n<li>systems function</li>\n<li>support activities</li>\n<li>data required for these activities</li>\n</ul>\n</li>\n<li>\n<p>Factors to consider:</p>\n<ul>\n<li>levels of management to be supported</li>\n<li>nature of functions</li>\n<li>types of activities to be performed</li>\n</ul>\n</li>\n</ul>\n<h4>Requirement Specifications</h4>\n<ul>\n<li>\n<p>This analysis can lead to the following two types of requirements:</p>\n<ul>\n<li>Information requirements:</li>\n<li>\n<p>specify the data under the auspices of the proposed database, including</p>\n<ul>\n<li>entities</li>\n<li>attributes</li>\n<li>and relationships among them</li>\n</ul>\n</li>\n<li>Processing requirements</li>\n<li>\n<p>the data manipulation requirements including:</p>\n<ul>\n<li>access frequencies</li>\n<li>required turnaround and response times</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4>Integrity Constraints</h4>\n<ul>\n<li>Discussions with the users lead to an understanding of the environment.</li>\n<li>\n<p>The information can be used to determine \"HOW\" the information is processed and what rules are applied to the data to ensure its integrity e.g.,</p>\n<ul>\n<li>unique employee ID number (primary key);</li>\n<li>children must have parents/guardians (foreign key(s));</li>\n</ul>\n</li>\n<li>These discussions are used to define the conceptual schema, including entities, relationships and attributed.</li>\n</ul>\n<hr>\n<p>Outcomes of analysis stage:</p>\n<ul>\n<li>Data requirements</li>\n<li>Properties and interrelationships of the data</li>\n<li>Operation requirements</li>\n<li>Significant events and termination conditions</li>\n<li>Constraints</li>\n</ul>\n<h3>Preliminary Design</h3>\n<ul>\n<li>Preliminary design is created</li>\n<li>Evaluated against the initial requirements</li>\n<li>Users are consulted</li>\n<li>Required changes are made</li>\n<li>This is an iterative process that continues until all users are satisfied</li>\n</ul>\n<p>Next step is to describe the system with a conceptual schema.</p>\n<h4>Conceptual Schema</h4>\n<p>Conceptual schema has nothing to do with the database that you have. It needs to be DBMS independent. It should be understandable to a non-specialist. Written using <strong>DDL - Data Definition Language</strong>.</p>\n<ul>\n<li>\n<p>Using the high-level model:</p>\n<ul>\n<li>Entities and relationships are identified</li>\n<li>attributes are explicitly stated</li>\n<li>primary keys are indicated</li>\n<li>relationship cardinalities are estimated</li>\n<li>constraints are specified (where possible)</li>\n</ul>\n</li>\n</ul>\n<h5>Building the Conceptual Schema</h5>\n<ul>\n<li>\n<p>Centralized Schema Design:</p>\n<ul>\n<li>requirements specification defined in a single set of specifications</li>\n<li>the conceptual schema is designed from this single set</li>\n</ul>\n</li>\n<li>\n<p>View Integration Approach:</p>\n<ul>\n<li>requirements specification for each user class forms the user view first, and then the conceptual schema is formed based on the individual views</li>\n<li>conflicts are resolved when the views are integrated</li>\n</ul>\n</li>\n</ul>\n<h3>Design Stage</h3>\n<p>After analysis stage, we begin to <strong>design</strong> the system. We need to define requirement for <strong>DBMS Software</strong>, <strong>hardware</strong>. After that, we proceed to <strong>final design</strong>, when we define the actual tables, and database. After design is complete and implemented, the final design needs to be <strong>tested</strong>.</p>\n<p>One of the first things that needs to be done is to decide what computing system you going to use.</p>\n<p>Fundamental:</p>\n<ul>\n<li>You are probably stuck with what you get</li>\n<li>try to work with it whenever possible</li>\n</ul>\n<p>Other considerations include things such as:</p>\n<ul>\n<li>\n<p>ensure existing DBMS has adequate storage and processing abilities</p>\n<ul>\n<li>e.g. can I increase the page size in chosen DBMS?</li>\n</ul>\n</li>\n<li>report generating facilities</li>\n<li>menu and form-based user interface (vs. terminal only)</li>\n<li>should the database be distributed</li>\n<li><em>expertise of the personnel</em> and their preferences</li>\n</ul>\n<h4>Data Model Selection (DBMS Level)</h4>\n<ul>\n<li>If data is mainly hierarchical, choose a hoerarchical model and a hierarchical DBMS</li>\n<li>If data exhibits a large number of interrelationships, the network or relational model would be preferable</li>\n<li>\n<p>Other factors:</p>\n<ul>\n<li>experience of personnel</li>\n<li>reputation of the vendor</li>\n<li>availability service from the vendor</li>\n</ul>\n</li>\n</ul>\n<p>Selection of the DBMS determines the data model.</p>\n<h4>Computer System Selection</h4>\n<p>Things to consider:</p>\n<ul>\n<li>Capital cost</li>\n<li>Conversion and initial training costs</li>\n<li>\n<p>Operating costs including:</p>\n<ul>\n<li>Personnel</li>\n<li>Maintenance of hardware/software</li>\n</ul>\n</li>\n</ul>\n<h4>The Three-schema Architecture</h4>\n<p><strong>DDL</strong> works with <em>schema</em>, <strong>DML</strong> works with <em>data</em>. When defining Internal Schema, use SDL.</p>\n<!-- TODO: Finish The Three-schema Architecture -->\n<h4>Final Design</h4>\n<p>To this point add design has been DBMS independent. Now the independent conceptual schema is translated to a DBMS dependent conceptual schema. Views of the application are derived from it as <em>external views</em>. First step is to convert from ER model to the DBMS dependent model:</p>\n<!-- TODO: Final Design -->\n<ul>\n<li>...</li>\n<li>...</li>\n</ul>\n<h4>Physical Database Design</h4>\n<p>Decisions are made regarding:</p>\n<ul>\n<li>Choice of clustering of records</li>\n<li>Choice of file organization</li>\n<li>Choice of supporting indexes</li>\n<li>Choice of links between records</li>\n</ul>\n<p>This is going to define the storage structure and how to optimize accesses.</p>\n<p>Performance considerations:</p>\n<ul>\n<li>Size of records</li>\n<li>Amount of data</li>\n<li>Data distribution over multiple storage devices</li>\n<li>Indexes vs. direct access mechanisms</li>\n</ul>\n<h5>Storage Strategies</h5>\n<p>Relational table can be fragmented: horizontally or vertically. <strong>Horizontal fragmentation</strong> - dividing table up into rows, e.g. subset of the data (query grad students vs. undergrad). <strong>Vertical fragmentation</strong> - dividing table up in columns, e.g. get only the column of the value (disregard some sensitive user info and extract only needed info). Fragmenting both horizontally and vertically would result in 2 copies of some cells, therefore updating will require to update both copies.</p>\n<p><strong>Hybrrid fragmentation</strong> - store both horizontal and vertical fragments.</p>\n<p>Problem with horizontal fragmentation: can't do aggregate queries well. Solution to that? vertical fragmentation. But it cannot be done at the same time. If a cell is in both vertical fragment and horizontal fragment, to write to it, need to lock both fragments.</p>\n<p>Hyper fragmentation: fragmenting both vertically and horizontally and store those fragments.</p>\n<!-- TODO: Storage Strategies -->\n<hr>\n<p>Physical design is an iterative process. Each attempt is analyzed to determine if performance will be acceptable. This is done analytically, rather than pragmatically. Potential pitfalls:</p>\n<ul>\n<li>file organization inappropriate for online transactions</li>\n<li>records must occur on the same physical drive</li>\n<li>improper storage units</li>\n<li>too much record overflow</li>\n</ul>\n<h4>Implementation and Testing</h4>\n<p>Implementation consists of writing and compiling code for conceptual and exernal schemes in the DDL of the DBMS. Physical database is created and loaded with data. Application programs and transactions are written, using a high-level language with embedded DML.</p>\n<p>When implemented, the design is tested to determine if functioning correctly. Documentation of the system is prepared. Backup and restart after failures are outlines.</p>\n<h3>Operational Stage</h3>\n<p><strong>Operational stage</strong> includes <strong>installation</strong> of the finished design. <strong>Operation and tuning</strong> of the design keeps on going, until new features are required/needed.</p>\n<h2>Entity Relationship Model</h2>\n<h2>Relational Data Model</h2>\n<h2>Relational Database Design</h2>\n<h2>Normalization</h2>\n<h2>Dependencies (Functional and Multi-value)</h2>","frontmatter":{"date":"September 10, 2019","title":"Database Design","description":"","published":true},"fields":{"slug":"/cpsc571/database-design","category":"cpsc571"}}},{"node":{"id":"a4dab8d7-1af5-516e-be01-d279a149cb21","html":"<!-- color: red\nfurniture: sofa\nflower: rose -->\n<p><strong>Information Technology</strong>(IT): relates to any computer tool that people use to work with.</p>","frontmatter":{"date":"September 09, 2019","title":"Introduction","description":"","published":false},"fields":{"slug":"/btma321/lec1","category":"btma321"}}},{"node":{"id":"13e8aed5-4e46-5097-a8d3-859378c5de43","html":"<h2>Security Triad</h2>\n<p>A computing system is secure only if it exhibits all three of these properties.</p>\n<ol>\n<li>Confidentiality - access to systems or data should be limited to \"authorized parties\".</li>\n<li>Integrity - Data should neither be intentionally tampered with nor accidentally corrupted.</li>\n<li>Availability - The system or data should always be there when you need (or want) it.</li>\n</ol>\n<h3>Security vs Reliability</h3>\n<p>Security has a lot to do with reliability. A secure system is one you can rely on to, e.g.,</p>\n<ul>\n<li>Keep your personal data confidential</li>\n<li>Allow only authorized access / modifications to resources.</li>\n<li>Give correct &#x26; meaningful results; and</li>\n<li>Give correct &#x26; meaningful results when you want them</li>\n</ul>\n<h2>Privacy</h2>\n<p><strong>What is privacy?</strong> Privacy is \"infomational self-determination\" (you get to control information about you). Control could mean many different things, e.g.,</p>\n<ul>\n<li>who gets to <em>see</em> is;</li>\n<li>who gets to <em>use</em> it;</li>\n<li>what they can use it for;</li>\n<li>who can they share it with...</li>\n</ul>\n<h3>PIPEDA</h3>\n<p>PIPEDA is Canada's private-sector privacy law. PIPEDA - <strong>P</strong>ersonal <strong>I</strong>nformation <strong>P</strong>rotection and <strong>E</strong>lectronic <strong>D</strong>ocuments <strong>A</strong>ct. Ten \"principles\":</p>\n<ol>\n<li>Identify purpose of data collection</li>\n<li>Obtain consent</li>\n<li>Limit collection</li>\n<li>Limit use, disclosure and retention</li>\n<li>Use appropriate safeguards</li>\n<li>Give individual access</li>\n<li>Be accurate</li>\n<li>Be open</li>\n<li>Be accountable</li>\n<li>Provide recourse</li>\n</ol>\n<h4>Security vs Privacy</h4>\n<p>Treating security and privacy as opposites is <strong>wrong</strong>.</p>\n<h2>How secure must it be?</h2>\n<p>Principle of <strong>Easiest Penetration</strong>:</p>\n<ul>\n<li>An attacker must be expected to use any available means of penetration.</li>\n<li>Attackers will go after the <strong>weakest link</strong>, not the <strong>most obvious link</strong> nor the most convinient link to fortify.</li>\n</ul>\n<p>Given that the attacker won't attack the obvious things, we must learn how to <strong>think like an attacker</strong> and protect weak links.</p>\n<p>Principle of <strong>Adequate Protection</strong>:</p>\n<ul>\n<li>Security <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding=\"application/x-tex\">\\subset</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">⊂</span></span></span></span> Economics: Digital assets should be protected to a degree consistent with their value and only until they lose their value.</li>\n</ul>","frontmatter":{"date":"September 09, 2019","title":"Principles of Computer Security","description":"","published":true},"fields":{"slug":"/cpsc525/lec1","category":"cpsc525"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}