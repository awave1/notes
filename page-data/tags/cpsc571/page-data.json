{"componentChunkName":"component---src-templates-tag-template-js","path":"/tags/cpsc571","webpackCompilationHash":"bf4ac3c4fc310c7d14d9","result":{"data":{"allMarkdownRemark":{"totalCount":3,"edges":[{"node":{"id":"0d8cd271-5deb-5d3e-9cdc-2425a6210599","html":"<h2>Buffer overread</h2>\n<p>The following code illustrates how improperly written code can be exploited. <code class=\"language-text\">buffer</code> array can only accept 16 characters, therefore if passed more than 16, the code will print information from memory from outside of assigned stack frame. This is called <strong>buffer overread</strong> flaw.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">char</span> buffer<span class=\"token punctuation\">[</span><span class=\"token number\">16</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">strncpy</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> argv<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s\\n\"</span><span class=\"token punctuation\">,</span> buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>Heartbleed (April 2014)</h4>\n<p>\"Heartbleed\" was a fault in OpenSSL versions released from 2012-2014. TLS Heartbeat mechanism prevents SSL/TLS timeouts when no data is being transmitted. One peer sends <strong>random data + payload length</strong>; other peer responds with identical payload.</p>\n<p>Code was missing a <strong>bounds check</strong>, therefore an attacker can request up to 64KB from server's private memory space.</p>\n<!--TODO: Finish heartbleed-->\n<hr>\n<h4>Apple's <code class=\"language-text\">goto fail;</code> (February 2014)</h4>\n<p>Fault in code used by OSX 10.9, iOS 6.1, to check validity of the signature key used by a server in a TLS</p>\n<!--TODO: Finish apple goto-->\n<h2>Buffer Overflows</h2>\n<p>Buffer overflows is among most commonly exploited security flaws</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> BUFF_LEN 1024</span>\n<span class=\"token keyword\">char</span> buffer<span class=\"token punctuation\">[</span>BUFF_LEN<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">strcpy</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> argv<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// or gets(buffer)</span></code></pre></div>\n<p>The <code class=\"language-text\">strcpy</code> (or <code class=\"language-text\">gets</code>) don't check whether the string they're copying actually fits in buffer. Some languages (e.g. Java) would throw an exception and crash the program. Not C/C++ - these languages don't notice something bad happened.</p>","frontmatter":{"title":"Principles of Computer Security","date":"2019-09-13","description":""},"fields":{"slug":"/cpsc525/lec3","category":"cpsc525"}}},{"node":{"id":"ddfe3a47-d094-533e-b63c-2220dcedeb5a","html":"<!-- TODO: Finish lec02 -->\n<h2>Nomenclature</h2>\n<ul>\n<li>Asset</li>\n<li>Vulnerability</li>\n<li>Threat</li>\n<li>Attack</li>\n<li>Control</li>\n</ul>","frontmatter":{"title":"Principles of Computer Security","date":"2019-09-11","description":""},"fields":{"slug":"/cpsc525/lec2","category":"cpsc525"}}},{"node":{"id":"5c03e963-8850-5a39-a964-6363dc4f295b","html":"<h2>Design Process</h2>\n<h3>Analysis Stage</h3>\n<p>Steps performed:</p>\n<ul>\n<li>Study existing system</li>\n<li>Meet with user groups</li>\n<li>Analyze existing procedures</li>\n<li>Modification to improve efficiency</li>\n<li>Prepare the initial proposal</li>\n</ul>\n<h4>Definition of Problem</h4>\n<ul>\n<li>To define a problem, develop a rough outline and scope the project.</li>\n<li>After the project is scoped, select an approach and determine its feasibility.</li>\n<li>\n<p>Estimate costs;</p>\n<ul>\n<li>initial setup</li>\n<li>operational</li>\n<li>risks versus benefits</li>\n</ul>\n</li>\n<li>Estimate time required for each part of the cycle</li>\n</ul>\n<h4>Existing System/Procedures Analysis</h4>\n<p>Analysis of the existing system is <strong>critical</strong>.</p>\n<ul>\n<li>Consider the way the things are done currently. Consider things to be present in current state of business.</li>\n<li>If possible, design the new system to <strong>minimize impact</strong>.</li>\n<li>Ask questions and talk to everyone you can.</li>\n<li>Determine any <em>sacred cow</em> and be very careful. Things like that need to be protected, because people care about those.</li>\n<li>\n<p>Find any:</p>\n<ul>\n<li>inefficiencies</li>\n<li>duplications</li>\n<li>procedural changes required</li>\n<li>how the new system will affect existing procedures</li>\n</ul>\n</li>\n<li>\n<p>Define explicitly the new systems requirements, including:</p>\n<ul>\n<li>systems function</li>\n<li>support activities</li>\n<li>data required for these activities</li>\n</ul>\n</li>\n<li>\n<p>Factors to consider:</p>\n<ul>\n<li>levels of management to be supported</li>\n<li>nature of functions</li>\n<li>types of activities to be performed</li>\n</ul>\n</li>\n</ul>\n<h4>Requirement Specifications</h4>\n<ul>\n<li>\n<p>This analysis can lead to the following two types of requirements:</p>\n<ul>\n<li>Information requirements:</li>\n<li>\n<p>specify the data under the auspices of the proposed database, including</p>\n<ul>\n<li>entities</li>\n<li>attributes</li>\n<li>and relationships among them</li>\n</ul>\n</li>\n<li>Processing requirements</li>\n<li>\n<p>the data manipulation requirements including:</p>\n<ul>\n<li>access frequencies</li>\n<li>required turnaround and response times</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4>Integrity Constraints</h4>\n<ul>\n<li>Discussions with the users lead to an understanding of the environment.</li>\n<li>\n<p>The information can be used to determine \"HOW\" the information is processed and what rules are applied to the data to ensure its integrity e.g.,</p>\n<ul>\n<li>unique employee ID number (primary key);</li>\n<li>children must have parents/guardians (foreign key(s));</li>\n</ul>\n</li>\n<li>These discussions are used to define the conceptual schema, including entities, relationships and attributed.</li>\n</ul>\n<hr>\n<p>Outcomes of analysis stage:</p>\n<ul>\n<li>Data requirements</li>\n<li>Properties and interrelationships of the data</li>\n<li>Operation requirements</li>\n<li>Significant events and termination conditions</li>\n<li>Constraints</li>\n</ul>\n<h3>Preliminary Design</h3>\n<ul>\n<li>Preliminary design is created</li>\n<li>Evaluated against the initial requirements</li>\n<li>Users are consulted</li>\n<li>Required changes are made</li>\n<li>This is an iterative process that continues until all users are satisfied</li>\n</ul>\n<p>Next step is to describe the system with a conceptual schema.</p>\n<h4>Conceptual Schema</h4>\n<p>Conceptual schema has nothing to do with the database that you have. It needs to be DBMS independent. It should be understandable to a non-specialist. Written using <strong>DDL - Data Definition Language</strong>.</p>\n<ul>\n<li>\n<p>Using the high-level model:</p>\n<ul>\n<li>Entities and relationships are identified</li>\n<li>attributes are explicitly stated</li>\n<li>primary keys are indicated</li>\n<li>relationship cardinalities are estimated</li>\n<li>constraints are specified (where possible)</li>\n</ul>\n</li>\n</ul>\n<h5>Building the Conceptual Schema</h5>\n<ul>\n<li>\n<p>Centralized Schema Design:</p>\n<ul>\n<li>requirements specification defined in a single set of specifications</li>\n<li>the conceptual schema is designed from this single set</li>\n</ul>\n</li>\n<li>\n<p>View Integration Approach:</p>\n<ul>\n<li>requirements specification for each user class forms the user view first, and then the conceptual schema is formed based on the individual views</li>\n<li>conflicts are resolved when the views are integrated</li>\n</ul>\n</li>\n</ul>\n<h3>Design Stage</h3>\n<p>After analysis stage, we begin to <strong>design</strong> the system. We need to define requirement for <strong>DBMS Software</strong>, <strong>hardware</strong>. After that, we proceed to <strong>final design</strong>, when we define the actual tables, and database. After design is complete and implemented, the final design needs to be <strong>tested</strong>.</p>\n<p>One of the first things that needs to be done is to decide what computing system you going to use.</p>\n<p>Fundamental:</p>\n<ul>\n<li>You are probably stuck with what you get</li>\n<li>try to work with it whenever possible</li>\n</ul>\n<p>Other considerations include things such as:</p>\n<ul>\n<li>\n<p>ensure existing DBMS has adequate storage and processing abilities</p>\n<ul>\n<li>e.g. can I increase the page size in chosen DBMS?</li>\n</ul>\n</li>\n<li>report generating facilities</li>\n<li>menu and form-based user interface (vs. terminal only)</li>\n<li>should the database be distributed</li>\n<li><em>expertise of the personnel</em> and their preferences</li>\n</ul>\n<h4>Data Model Selection (DBMS Level)</h4>\n<ul>\n<li>If data is mainly hierarchical, choose a hoerarchical model and a hierarchical DBMS</li>\n<li>If data exhibits a large number of interrelationships, the network or relational model would be preferable</li>\n<li>\n<p>Other factors:</p>\n<ul>\n<li>experience of personnel</li>\n<li>reputation of the vendor</li>\n<li>availability service from the vendor</li>\n</ul>\n</li>\n</ul>\n<p>Selection of the DBMS determines the data model.</p>\n<h4>Computer System Selection</h4>\n<p>Things to consider:</p>\n<ul>\n<li>Capital cost</li>\n<li>Conversion and initial training costs</li>\n<li>\n<p>Operating costs including:</p>\n<ul>\n<li>Personnel</li>\n<li>Maintenance of hardware/software</li>\n</ul>\n</li>\n</ul>\n<h4>The Three-schema Architecture</h4>\n<p><strong>DDL</strong> works with <em>schema</em>, <strong>DML</strong> works with <em>data</em>. When defining Internal Schema, use SDL.</p>\n<!--\n#TODO: Finish The Three-schema Architecture\n-->\n<h4>Final Design</h4>\n<p>To this point add design has been DBMS independent. Now the independent conceptual schema is translated to a DBMS dependent conceptual schema. Views of the application are derived from it as <em>external views</em>. First step is to convert from ER model to the DBMS dependent model:</p>\n<!--\n#TODO: Final Design\n-->\n<ul>\n<li>...</li>\n<li>...</li>\n</ul>\n<h4>Physical Database Design</h4>\n<p>Decisions are made regarding:</p>\n<ul>\n<li>Choice of clustering of records</li>\n<li>Choice of file organization</li>\n<li>Choice of supporting indexes</li>\n<li>Choice of links between records</li>\n</ul>\n<p>This is going to define the storage structure and how to optimize accesses.</p>\n<p>Performance considerations:</p>\n<ul>\n<li>Size of records</li>\n<li>Amount of data</li>\n<li>Data distribution over multiple storage devices</li>\n<li>Indexes vs. direct access mechanisms</li>\n</ul>\n<h5>Storage Strategies</h5>\n<p>Relational table can be fragmented: horizontally or vertically. <strong>Horizontal fragmentation</strong> - dividing table up into rows, e.g. subset of the data (query grad students vs. undergrad). <strong>Vertical fragmentation</strong> - dividing table up in columns, e.g. get only the column of the value (disregard some sensitive user info and extract only needed info). Fragmenting both horizontally and vertically would result in 2 copies of some cells, therefore updating will require to update both copies.</p>\n<p><strong>Hybrrid fragmentation</strong> - store both horizontal and vertical fragments.</p>\n<p>Problem with horizontal fragmentation: can't do aggregate queries well. Solution to that? vertical fragmentation. But it cannot be done at the same time. If a cell is in both vertical fragment and horizontal fragment, to write to it, need to lock both fragments.</p>\n<p>Hyper fragmentation: fragmenting both vertically and horizontally and store those fragments.</p>\n<!--\n#TODO: Storage Strategies\n-->\n<hr>\n<p>Physical design is an iterative process. Each attempt is analyzed to determine if performance will be acceptable. This is done analytically, rather than pragmatically. Potential pitfalls:</p>\n<ul>\n<li>file organization inappropriate for online transactions</li>\n<li>records must occur on the same physical drive</li>\n<li>improper storage units</li>\n<li>too much record overflow</li>\n</ul>\n<h4>Implementation and Testing</h4>\n<p>Implementation consists of writing and compiling code for conceptual and exernal schemes in the DDL of the DBMS. Physical database is created and loaded with data. Application programs and transactions are written, using a high-level language with embedded DML.</p>\n<p>When implemented, the design is tested to determine if functioning correctly. Documentation of the system is prepared. Backup and restart after failures are outlines.</p>\n<h3>Operational Stage</h3>\n<p><strong>Operational stage</strong> includes <strong>installation</strong> of the finished design. <strong>Operation and tuning</strong> of the design keeps on going, until new features are required/needed.</p>\n<h2>Entity Relationship Model</h2>\n<h3>Data Modeling</h3>\n<p>In general, a model is a detail hiding abstraction that highlights the components of direct or most interest. <strong>Data model</strong> is a mechanism for accomplishing this for database applications. It should be able to capture:</p>\n<ul>\n<li>entities and their attributes</li>\n<li>inter and intra-entity relationships</li>\n<li>appropriate constraints on the data</li>\n</ul>\n<p>Current systems most often model data with either the:</p>\n<ul>\n<li>hierarchical, network, or</li>\n<li>relational data model</li>\n<li>\n<p>object-oriented model</p>\n<ul>\n<li>True object-oriented databases do not exists</li>\n</ul>\n</li>\n<li>graph model</li>\n</ul>\n<h3>Semantic data models</h3>\n<p>Class of models created to capture <em>what</em> data means. Developed originally to capture \"knowledge\" inherent in the world. They should be able to:</p>\n<ul>\n<li>organize and</li>\n<li>represent general knowledge</li>\n</ul>\n<p>The most used semantic data model is the <strong>Entity Relationship Model</strong>.</p>\n<h4>Entity Relationship Model</h4>\n<p>Developed approximately from the hierarchical and network models. ER permits explicit representation of <strong>constraints</strong> and <strong>relationship</strong>.</p>\n<!--\n#TODO: Finish Entity Relationship Model\n-->\n<h5>Entity</h5>\n<p>An entity is an object that is of interest to an organization. All objects are unique and must be identified by a unique name. An object may belong to more than one entity, e.g;</p>\n<ul>\n<li>\n<p>University Athlete</p>\n<ul>\n<li>hockey player</li>\n<li>football player</li>\n<li>women's track coach</li>\n</ul>\n</li>\n</ul>\n<p>A subset of an entity's</p>\n<!--\n#TODO: Finish Entity\n-->\n<h6>Strong Entity</h6>\n<!--\n#TODO: Finish strong Entity\n-->\n<h6>Weak Entity</h6>\n<!--\n#TODO: Finish weak Entity\n-->\n<p><strong>Identifying relationship</strong> is the one that links a strong entity to a subordinate. A <strong>weak entity</strong> is an entity that is not uniquely identified by its attributes. <strong>Discriminator</strong>: ... .</p>\n<h5>Relationship</h5>\n<p><strong>Relationship set</strong> is a collection of relations of the same type.</p>\n<!--\n#TODO: Finish relationship\n-->\n<h6>Keying Relaionships</h6>\n<!--\n#TODO: Finish keying relationship\n-->\n<h4>Aggregation</h4>\n<p><strong>Aggregation</strong> is the process ... .</p>\n<h2>Relational Data Model</h2>\n<h2>Relational Database Design</h2>\n<h2>Normalization</h2>\n<h2>Dependencies (Functional and Multi-value)</h2>","frontmatter":{"title":"Database Design","date":"2019-09-10","description":""},"fields":{"slug":"/cpsc571/database-design","category":"cpsc571"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tag":"cpsc571"}}}